---
layout: post
title:  "C#基础 委托"
categories: C#基础
tags: C#基础 委托
author: GHMicoos
---


* content
{:toc}

委托是**寻址方法**的.NET版本。委托类不仅包含对方法的引用，也包括对多个方法的引用。


声明使用委托
`delegate void Method(int param);`
* “定义一个委托”实际上是“定义一个新类”。

``` js

//定义委托
private delegate string GetAString();
static void Main(string[] args)
{
    var x = 10;
    //用方法给委托变量赋值
    //等价于 GetAString delegateObj=new GetAString(x.ToString);
    GetAString delegateObj = x.ToString;
    //delegateObj() 等价于 delegateObj.INvoke();
    Console.WriteLine($"委托调用：{delegateObj()}");
}

```

委托的特点
* 委托是类型安全的，可以确保被调用的方法的签名是正确的。
* 委托只注意方法的签名，而不关心在什么类型的对象上调用该方法，甚至不考虑该方法是静态的或者实例的。




3.系统自定义委托
* `Action<T>`：定义了一个void返回类型的泛型委托。拥有多种变形。
* `Func<T>`:定义了有返回类型的泛型委托。拥有多种变形。

``` js

private delegate string GetAString();
class TestDelegate
{
    public static void ForAction()
=> Console.WriteLine("ForAction Method.");

    public static string ForFunc(object obj)
=> obj.ToString();
}

//测试代码
Action a = TestDelegate.ForAction;
var i = "I am string.";
Func<string,string> fun = TestDelegate.ForFunc;
//输出 ForAction Method.
a();
//输出 I am string.
fun(i);

```

多播委托
解释：委托可以包含多个方法。调用该委托时，会按照顺序（顺序不可预测）连续调用多个方法。
* 可以使用`+=`、`-=`操作符来向委托中添加或者删除方法。（委托重载了这两个操作符）

特点
* 如果多播委托中的方法有返回值，那么只能返回最后一个方法的返回结果。
* 多播委托中的方法调用顺序是不可预测的，避免编写依赖以特定顺序调用方法的代码。
* 因为调用多播委托时，会调用委托中包含的方法，但是如果其中一个方法抛出异常，那么整个迭代就会停止。

匿名方法:在需要使用委托实例的时候，但是该方法又只使用一次，就可以已定义一个匿名方法用于传递给委托实例。

``` js

Func<string, int> getLength = delegate (string param)
  {
      return param?.Length ?? -1;
  };

```

Lambda表达式：


二 事件

* 事件基于委托，为委托提供一种发布/订阅机制。

事件的特点
`public delegate void EventHandler<TEventArgs>(object sender, TEventArgs e);`
* 事件一般使用带两个参数的方法；其中一个参数是一个对象，包含事件的发送者；第二个参数提供事件的相关信息。

``` js

class CarInfoEventArgs : EventArgs
{
    public string Car { get; private set; }
    public CarInfoEventArgs(string car)
        => Car = car;
}

class CarDealer
{
//可以使用下面的 C#的简化写法
//public event EventHandler<CarInfoEventArgs> NewCarInfo;
    private EventHandler<CarInfoEventArgs> _newCarInfo;
    public event EventHandler<CarInfoEventArgs> NewCarInfo
    {
        add { _newCarInfo += value; }
        remove { _newCarInfo -= value; }
    }


    public void NewCar(string car)
    {
        Console.WriteLine($"CarDealer,new car {car}");
        if (_newCarInfo != null)
        {
        _newCarInfo(this, new CarInfoEventArgs(car));
        }
    }
}

class Customer
{
    private string name;
    public Customer(string name)
        => this.name = name;

    public void NewCarIsHere(object sender, CarInfoEventArgs e)
    {
        Console.WriteLine($"{name}:car {e.Car} is new");
    }
}

//测试代码
var dealer = new CarDealer();
//michael对象 订阅 dealer的NewCarInfo方法
var michael = new Customer("Michael");
dealer.NewCarInfo += michael.NewCarIsHere;

var nick = new Customer("Nick");
//nick对象 订阅 dealer的NewCarInfo方法
dealer.NewCarInfo += nick.NewCarIsHere;

//dealer 发布动作，然后会依次调用订阅方法
//输出：
/*
CarDealer,new car 新车马自达
Michael:car 新车马自达 is new
Nick:car 新车马自达 is new
*/
dealer.NewCar("新车马自达");

```



弱事件
* 通过事件，直接连接到发布程序和侦听器。但是垃圾回收的时候会有一个问题，如果侦听器其他地方不在直接引用，但是发布程序仍然会有一个引用存在。那么，垃圾回收不能清空侦听器。这种情况可以通过弱事件模式来处理。


