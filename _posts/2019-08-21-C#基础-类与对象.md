---
layout: post
title:  "C#基础 类与对象"
categories: C#基础
tags: C#基础 类与对象
author: GHMicoos
---


* content
{:toc}

[概述]

类：创建对象的模板。
类的访问修饰符：public internal
但是嵌套类的访问修饰符会更多
类的成员：类中的数据和函数成
类的成员
    嵌套的类型
    数据成员
        字段
        常量
        事件
    函数成员
        方法
        属性：可以从类外部访问的方法组。
        构造函数：实例化对象时自动调用的特殊函数。
        终接器：类似于构造函数，是在CLR中检到不再需要某个对象时候调用它。不肯能预测什么时候调用终接器。
        运算符
        索引器

类成员的访问修饰符：`public` `private` `protected` `internal` `protected` `internal`

给方法传递参数：参数默认是传值的
引用类型与值类型对比：
    传递的参数是值类型还是引用类型并不重要。重要的是目标方法是否能将一个新值赋给调用者的初始变量。由于会生成一份副本，所以不可能重新对调用者的副本进行赋值。
    跟具体的说，引用类型的变量包含实际数据所在的内存地址。假如以传值方式来传递一个引用类型的变量，地址会从调用者赋值给方法参数。其结果就是，目标方法不能更新调用者的变量的地址值。另一方面，假如方法参数是一个值类型，值本身会被复制到参数中，更改参数不会影响调用者的原始变量。
ref参数（引用参数）：C要求对传递给方法的参数进行初始化。
out参数（输出参数）：传递变量给方法时候可以不进行初始化，但是在方法中必须对变量进行赋值。
参数数组：有时候希望参数的数量是可变的。
    参数数组要求：
    参数数组不一定是方法声明中的唯一采参数。但是，参数数组必须是方法声明中的最后一个参数。由于只有最后一个参数才能是参数数组，所以方法最多只能有一个参数数组。
    调用者可以为参数数组指定零个参数，这会造成包含零个数据项的一个数组。
    参数数组是类型安全的--传入参数类型必须匹配与数组指定的类型。
    调用者可以显示地使用一个数组，而不是以逗号分割的参数列表。最终生成的CLI代码是一样的。
    假如目标方法的实现要求一个最起码的参数数量，请在方法声明中显示指定必须提供的参数。int Max(int first ,params int[] paramList)
命名参数：传递参数给方法时参数需要按照一定的顺序。命名参数运行按任意顺序传递。
`FullName(lastName:"coos",firstName:"mi")`
可选参数：可选参数必须是方法定义的最后一个参数，必须给可选参数定义默认值。

方法的重载：
重载：方法的几个版本有不同的签名。
方法签名：方法名相同，但是参数个数/参数类型不同。（方法返回类型不是方法签名的关注点）
重载方法：不能仅在方法的返回类型上有区别，也不能仅仅根据参数是声明为out还是ref来区分。

属性：
只读/只写属性：缺省对应的访问器。
属性访问器的修饰符：
    访问器没有修饰符，默认为属性的修饰符。
    get/set访问器中，必须有一个具备属性的访问修饰符。
    访问器的修饰符级别不能超过属性的访问级别。
自动属性：如果属性中get/set访问器没有任何逻辑，就可以使用自动实现的属性。
    不能缺省访问器
    每个访问器的访问级别可以不同。
属性作为虚字段使用：属性的行为与虚字段相似，某些情况下，甚至根本不需要一个支持字段。相反，可以让属性的取值方法放回一个计算好的值，而让赋值方法解析值，并把它持久存储到其他一些成员字段中。
属性和方法调用不允许作为ref或者out参数值使用



构造函数：函数名与类名相同，但是没有返回值（返回值不能是void）。

默认构造函数：它能把所有的成员字段初始化为类型的默认值。
如果类不提供构造函数，编译器会自动生成一个默认的构造函数。
如果类提供了构造函数，编译器就不会自动提供默认构造函数。

静态构造函数：
编写静态构造函数的原因：类有一些静态字段或属性，需要在第一次使用类之前，从外部源中初始化这些字段和属性。
静态构造函数只执行一次，即在代码引用类之前调用它，通常在第一次调用类的任何成员之前执行静态构造函数。
.NET运行库没有确保什么时候执行静态构造函数
也不能预计不同类的静态构造函数的执行顺序

构造函数中调用本类的其他构造函数，使用this

readonly与cont区别
常量
    只能在声明时候赋值。
    只能赋值编译时候能确定的值，一般是字面量。
    在程序编译过程中，会把常量转换为字面量，如此一来如果更改了字面量然后在编译，那么之前编译的版本值不会变。
    常量默认是static的，但是不能显式加上static
readonly
    可以在声明时候赋值，也可以在狗仔函数中赋值
    可以赋值变量
    可以是实例的，也可以是静态的

匿名类：是一个继承自Object且没有名称的类。
var obj=new{FirstName="mi",LastName="coos"};
还可以简化初始化器
var obj1=new {obj.FirstName,obj.LastName};

弱引用：特殊地创建对象，但是当垃圾回收期运行时就会回收对象，释放引用。
强引用：实例化一个类或者结构时，只要有代码引用它，就会形成一个强引用（意味着垃圾回收器不会回收）。

部分类（结构，方法，接口）
partial关键字允许把类，方法，接口放在多个文件中。
为代码生成器生成类提供方便。

静态类：如果类只包含静态方法和属性，就可以把类定义成静态的。

扩展方法：










### 零 类型的分类

#### **0.值类型**
 * 1.变量直接存储值。
 * 2.存储在堆栈中
#### **0.值类型**
 * 1.存储值的引用，也就是存储值的内存地址。
 * 2.存储在托管堆中

* 每个引用总是处理器的“原生大小”。也就是，32位处理器引用大小是32位，64位处理器引用大小是64位。


### 一 预定义值类型
#### **0. 8种整数类型**

| 类型 | 大小 | 后缀 | BCL名称 | 范围 |
| :------| :------ | :------ | :------ | :------ |
| sbyte  | 8位  |       | System.SByte  | -128~127(-2^7~2^7-1) |
| short  | 16位 |       | System.Int16  | -32768~32767(-2^15~2^15-1) |
| int    | 32位 |       | System.Int32  | -2147 482 648~2147 482 647(-2^31~2^31-1) |
| long   | 64位 | L/l   | System.Int64  | -9223 372 036 854 775 808 ~9223 372 036 854 775 807(-2^63~2^63-1) |
| byte   | 8位  |       | System.Byte   | 0~255(0~2^8-1) |
| ushort | 16位 |       | System.UInt16 | 0~65535(0~2^16-1) |
| uint   | 32位 | U/u   | System.UInt32 | 0~4294 967 295(0~2^32-1) |
| ulong  | 64位 | UL/ul | System.UInt64 | 0~18 446 744 073 709 551 615(0~2^64-1) |


#### **1. 2种用于科学计算的二进制浮点类型**

| 类型 | 大小 | 有效数字 | BCL名称 | 后缀 |
| :------ | :------ | :------ | :------ |
| float   | 32位  | 7     | System.Single  | F/f |
| double  | 64位  | 15/16 | System.Double  | D/d |

#### **2. 1种用于金融计算的十进制浮点类型**

| 类型 | 大小 | 有效数字 | BCL名称 | 后缀 |
| :------ | :------ | :------ | :------ |
| decimal   | 128位  | 28/29 | System.Decimal  | M/m |

#### **3. 1种布尔值类型**

#### **4. 1种字符类型**







#### **1.C#中的预定义值类型**
* object类型
* string类型



* ModelState的位置
![ModelState](https://raw.githubusercontent.com/GHMicoos/GHMicoos.github.io/master/images/blog/DotNetCore%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81/ModelState_Place.jpg "位置")
* ModelState.IsValid 表示`模型绑定`、`模型验证`是否都是都成功。模型绑定的错误通常是数据转换错误。模型验证的错误通常是数据不符合业务规则。
* 如何获取模型绑定和模型验证的错误消息
``` js
 foreach (var item in ModelState.Values)//一个Model可能有多个字段
 {
     foreach (var jitem in item.Errors)//一个字段可能有多个错误
     {
         jitem.ErrorMessage;//string
     }
 }
```

#### **2.Web与Web Api 的模型验证**
* 模型绑定和验证都在执行控制器操作或 Razor Pages 处理程序方法之前进行。 Web 应用负责检查 ModelState.IsValid 并做出相应响应。 Web 应用通常会重新显示带有错误消息的页面：
* 如果 Web API 控制器具有 `[ApiController]` 特性，则它们不必检查 `ModelState.IsValid`，在此情况下，如果模型状态无效，将返回包含问题详细信息的自动 HTTP 400 响应。

#### **3.重新运行模型验证**
* 验证自动进行，但是可能需要手动进行重复验证。 例如，你可能为属性计算一个值，并且希望将属性设置为所计算的值后，再重新运行验证。 
* 使用代码 `TryValidateModel(model)`


### 二 模型验证

#### **1.验证特性**
* 通过验证特性可以为模型属性指定验证规则。包括：内置特性、自定义特性。

#### **2.内置特性**
* `[CreditCard]`：验证属性是否有信用卡格式。
* `[Compare]`：验证模型中的两个属性是否匹配。
* `[EmailAddress]`：验证属性是否有电子邮件格式。
* `[Phone]`：验证属性是否有电话号码格式。
* `[Range]`：验证属性值是否在指定范围内。
* `[RegularExpression]`：验证属性值是否与指定的正则表达式匹配。
* `[Required]`：验证字段是否非 NULL。 请参阅 [必需] 特性，获取关于该特性的行为的详细信息。
* `[StringLength]`：验证字符串属性值是否未超过指定长度限制。
* `[Url]`：验证属性是否有 URL 格式。
* `[Remote]`：通过调用服务器上的操作方法，验证客户端上的输入。 请参阅 [远程] 特性获取关于该特性的行为的详细信息。

* 在 [`System.ComponentModel.DataAnnotations`](https://docs.microsoft.com/zh-cn/dotnet/api/system.componentmodel.dataannotations?view=netframework-4.8) 命名空间中可找到验证特性的完整列表

* 错误消息：`[StringLength(8, ErrorMessage = "Name length can't be more than 8.")]`
